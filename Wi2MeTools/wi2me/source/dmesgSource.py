# Copyright (c) 2012 Institut Mines-Telecom / Telecom Bretagne. All rights reserved.
#
# This file is part of Wi2Me.
#
# Wi2Me is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Wi2Me is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Wi2Me.  If not, see <http://www.gnu.org/licenses/>.
#

# This source modules parses dmesg log files generated by a custom build of mac80211.ko
# The path parameter is the top directory of the mesurements
# The expected hierrachy is as follow
# $MESUREMENT_ROOT/$POSITIONS/$EXPERIMENTS/$SCAN_FILES
# $MESUREMENT_ROOT is the parameter given to the ctor
# /$POSITIONS are directories named by numbers reprensenting a physical location
# $EXPERIMENTS are directories named by numbers representing the experiments that are to be done for each position
# $SCAN_FILES can be mandatory _kernel files or optionnal _iw files and named using the following format : 
# scan_log-$TIMESTAMP_$SCANOCCURENCE_kernel
# _kernel files contain the logs from the custom kernel retrieved by dmesg using the following format : 
#[  301.088339] ##presponse;net/mac80211/scan.c;ieee80211_scan_rx;256;1089;nic_freq=2467;nic_band=0;signal=-69;mactime=32828;frame_control=50;addr1=00:1b:77:5b:34:bf;addr2=6a:7e:cb:ac:00:c7;addr3=6a:7e:cb:ac:00:c7;addr4=ab:04:62:ff:20:00;duration_id=314;seq_ctrl=42928;retry=0;timestamp=141723567275;beacon_interval=100;capability_info=411;hw_permaddr=00:1b:77:5b:34:bf##

# _iw files are optionnal and must be named the same way as the _kernel files it is associated to except for an _iw suffix instead of _kernel. They simply contain the output of the iwscan linux command

import os 
from wi2me.model.AP import AP, Network, Detection
import SourceHelper
import numpy as np 

SCAN_SET_CHANNEL = "scan_set_channel"
SCAN_SEND_PROBE = "scan_send_probe"
SCAN_PRESPONSE = "presponse"
SCAN_BEACON = "beacon"

BSS_KEY = "BSS"
LOAD_KEY = "Load:\n"
FREQ_KEY = "freq:"

KERNEL_BSSID_KEY = "addr3="
KERNEL_FREQ_KEY = "nic_freq="
KERNEL_RSSI_KEY = "signal="
KERNEL_UPTIME_KEY = "timestamp="

KERNEL_FILE_SUFFIX = "_kernel"
IW_FILE_SUFFIX = "_iw"

IW_BSS_KEY = "BSS "
IW_SSID_KEY = "SSID: "
IW_TSF_KEY = "TSF:"
IW_TSF_USEC_KEY = "usec"

FREQUENCIES = {
	2412:1,
	2417:2,
	2422:3,
	2427:4,
	2432:5,
	2437:6,
	2442:7,
	2447:8,
	2452:9,
	2457:10,
	2462:11,
	2467:12,
	2472:13,	
}

def extractKernelVar(line, key):
	retval = ""
	for field in line:
		if field.find(key) > -1:
			retval = field[field.find(key) + len(key):]
	return retval


def readIwFile(path):
	#bssid, tsf as keys
	#ssid as values
	retval = {}
	f = open(path, 'r')
	key = ''
	uptime = 0
	for l in f.readlines():
		if l.startswith(IW_BSS_KEY):
			key = l.split(' ')[1]
		elif IW_TSF_KEY in l:
			uptime = int(l[l.index(IW_TSF_KEY) + len(IW_TSF_KEY): l.index(IW_TSF_USEC_KEY) - 1])
		elif IW_SSID_KEY in l:
			ssid = l[l.index(IW_SSID_KEY) + len(IW_SSID_KEY):].rstrip('\n')

			retval[key, uptime] = ssid
			key = ''
			uptime = 0

	return retval


def freq2Chan(freq):
	retval = -1

	if freq in FREQUENCIES:
		retval = FREQUENCIES[freq]

	return retval

class dmesgSource:

	def __init__(self, path, presponse = True, beacons = True, mergeAPs = True):
		self.path = path
		self.presponse = presponse
		self.beacons = beacons
		self.origin = SourceHelper.ORIGIN_DMESG
		self.name = SourceHelper.shortName(path)
		self.mergeAPs = mergeAPs
		self.tags = []

	############################### Time related functions

	
	#timestamp for the beginning of the mesurements
	# Both this one and the following are very lazy implementation, but the required processing power is prety limited anyway
	def getStartTime(self):
		retval = min([det.timestamp for nws in self.getScanResults() for nw in nws for det in nw.detections])
		return retval

	#timestamp for the end of the mesurements
	def getEndTime(self):
		retval = max([det.timestamp for nws in self.getScanResults() for nw in nws for det in nw.detections])
		return retval

	############################### Geolocalisation related functions

	#Total travelled distance in meters
	def getTravelledDistance(self):
		retval = 0
		return retval


	#minimal and maximal latitude ant longitude in order to delimitate the place the mesurements took place in
	#The expected order is [lat_min, lat_max, long_min, long_max]
	def getExtremeCoordinates(self):
		return [0, 0, 0, 0]


	#Get the GPS coordinates of points contained in a certain timerange (or all of them)
	def getPoints(self, timeRange=None):
		return []



	############################### Access point discovery related functions
	def _getScanResult(self, path, scanInd = 0):
		APS = {}
		scanF = open(path, 'r')

		# Maybe we have an associated iw file that will give us the SSID, store that in a dictionnary for now
		iwPath = path.replace(KERNEL_FILE_SUFFIX, IW_FILE_SUFFIX)
		ssids = {}
		if os.path.exists(iwPath):
			ssids = readIwFile(iwPath)
			
		# Now parse the actual data
		for l in scanF.readlines():
			if len(l) <= 1:
				continue
			ts = int(l[2:l.find(']')].replace('.', ''))

			l = l[l.find('##') + 2:]
			data =  l.split(';')

			if (data[0] == SCAN_BEACON and self.beacons) or (data[0] == SCAN_PRESPONSE and self.presponse):
				uptime = int(extractKernelVar(data, KERNEL_UPTIME_KEY))
				bssid = extractKernelVar(data, KERNEL_BSSID_KEY)
				level = int(extractKernelVar(data, KERNEL_RSSI_KEY))
				channel = freq2Chan(int(extractKernelVar(data, KERNEL_FREQ_KEY)))

				ssid = ""

				for l_bssid, l_uptime in ssids:
					if uptime == l_uptime and bssid in l_bssid:
						ssid = ssids[l_bssid, l_uptime]

				#APS.append(AP(bssid, level, uptime=uptime, timestamp = ts, ssid = ssid, source = data[0], channel = channel))
				if bssid in APS:
					APS[bssid].detections.append(Detection(source = data[0], timestamp = ts, rssi = level))
				else:
					APS[bssid] = Network(bssid = bssid, ssid=ssid, channel = channel, detections=[Detection(source = data[0], timestamp = ts, rssi = level, scanInd = scanInd)])

		scanF.close()

		return APS.values()

	#get a list of list of scan results (one list for each attempt)
	def getScanResults(self, gpsRange = None):
		retval = []
		dirlist = os.listdir(self.path)
		dirlist = [int(i) for i in dirlist]
		numPos = len(dirlist)
		scanInd = 0
		for position in sorted(dirlist):
			if os.path.isdir(self.path + str(position)):
				
				explist = os.listdir(self.path + str(position))
				explist = [int(i) for i in explist]
				for experiment in sorted(explist):

					if os.path.isdir(self.path + str(position) + os.path.sep + str(experiment)):
						for _, _, scanList in os.walk(self.path + str(position) + os.path.sep + str(experiment)):
							for scan in scanList:

								ScanFileName = self.path + str(position) + os.path.sep + str(experiment) + os.path.sep + scan
								if ScanFileName.endswith(KERNEL_FILE_SUFFIX):
						
									retval.append(self._getScanResult(ScanFileName, scanInd = scanInd))
									scanInd += 1

		return retval


	#Retrieve list of all APs seen in the trace
	def getApList(self):
		return [ap for aps in self.getScanResults() for ap in aps]


	#Return the number of scan attempts
	def countScans(self):
		retval = 0
		dirlist = os.listdir(self.path)
		dirlist = [int(i) for i in dirlist]
		numPos = len(dirlist)
		for position in sorted(dirlist):
			if os.path.isdir(self.path + str(position)):
				
				explist = os.listdir(self.path + str(position))
				explist = [int(i) for i in explist]
				for experiment in sorted(explist):

					if os.path.isdir(self.path + str(position) + os.path.sep + str(experiment)):
						for _, _, scanList in os.walk(self.path + str(position) + os.path.sep + str(experiment)):
							retval += len(scanList)

		return retval

	############################### Device Event related functions
	
	#Get device connectivity events
	def getEvents(self, eventTypes = None):
		return []

	#Get device community network events
	def getCNEvents(self, eventTypes = None):
		return []

	############################### Transmitted Data related functions

	#Get a list of the data transfer events, with the associated AP
	def getTransferredData(self):
		return []
 
