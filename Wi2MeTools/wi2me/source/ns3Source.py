# Copyright (c) 2012 Institut Mines-Telecom / Telecom Bretagne. All rights reserved.
#
# This file is part of Wi2Me.
#
# Wi2Me is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Wi2Me is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Wi2Me.  If not, see <http://www.gnu.org/licenses/>.
#


# This source modules parses sqlite databases generated by the wi2me android application 

import os
import sqlite3
from wi2me.model.AP import AP, Network, Detection
from wi2me.model.ConnectionEvent import *
from wi2me.model.TransferredData import *
import SourceHelper
import inspect
import csv
import itertools
import tempfile

from wi2me.model.ConnectionEvent import TYPE_DISCONNECTED, TYPE_ASSOCIATED, TYPE_ASSOCIATING, TYPE_RSSI_CHANGE
import math

CSV_SEP = "\t"

TAG_SCAN = "scan"
TAG_L2EVENT = "l2event"
TAG_TRAFFIC = "traffic"
TAG_SORTED = "SORTED"
TAG_COORDINATE = "position"

L2EVENTS = {
    "0":TYPE_ASSOCIATING,
    "1":TYPE_ASSOCIATED,
    "2":TYPE_DISCONNECTED,
    "3":TYPE_RSSI_CHANGE,
}

SOURCES = {0:"beacon", 1:"presponse"}
       
 
def intToBssid(val):
    retval = list("00:00:00:00:00:00")
    ind = len(retval) - 1
    for u in hex(val)[2:][::-1]:
        if retval[ind] == ":":
            ind -= 1
        retval[ind] = u
        ind -= 1

    return ''.join(retval)

def _lineToTs(line, ppp):
    retval = 0
    data = line.split(CSV_SEP)
    if len(data) > 1:
        try:
            retval  =int(data[0])
        except ValueError, e:
            retval = 0
    return retval


class ns3Source:
	def __init__(self, path):
		self.path = path
		self.origin = SourceHelper.ORIGIN_NS3
		self.name = SourceHelper.shortName(path)
		self.tags = []

                self._ensureSorted()

	############################### Time related functions



        #Lines incoming from ns3 might not be sorted, therefore, we sort them of needed and add a SORTED tag to avoid redoing it
        def _ensureSorted(self):
                ts = 0
                fSorted = False
                csvfile = open(self.path, 'rb') 
                while ts == 0 and not fSorted:
                    data = csvfile.readline().rstrip('\n').split(CSV_SEP)
                    if len(data) <= 1:#Failed campaign with only configuration
                        break
                    else:
                        ts = int(data[0])
                        fSorted = data[1] == TAG_SORTED

                if not fSorted:
                    csvfile.seek(0)
                    newF = tempfile.NamedTemporaryFile('w', delete=False)
                    newF.write("0")
                    newF.write(CSV_SEP)
                    newF.write(TAG_SORTED)
                    newF.write('\n')
                    newF.writelines(sorted(csvfile.readlines(), key = lambda x : _lineToTs(x, self.path)))

                    newF.close()
                    os.rename(newF.name, self.path)

        def _readlines(self, tags):

                csvfile = open(self.path, 'rb') 
                linereader = csv.reader(csvfile, delimiter=CSV_SEP)
                retval = itertools.ifilter(lambda p: len(p) >= 2 and p[1] in tags, linereader)

                return retval

	#timestamp for the beginning of the mesurements
	def getStartTime(self):
		return 0

	#timestamp for the end of the mesurements
        def getEndTime(self):
                f = open(self.path)
                ll = ""
                for l in f.readlines():
                    if CSV_SEP in l:
                        ll = l
                    pass

                data = ll.rstrip('\n').split(CSV_SEP)
                ts = int(data[0])

                f.close()
                return ts


	#If the database contains multiple occurence where the app was started and stopped
	def getSessions(self):
		retval = []
                retval.append((self.getStartTime(), self.getEndTime()))
		return retval



	############################### Geolocalisation related functions

	#minimal and maximal latitude ant longitude in order to delimitate the place the mesurements took place in
	#The expected order is [lat_min, lat_max, long_min, long_max]
	def getExtremeCoordinates(self):
                print(inspect.currentframe().f_code.co_name) + "    NO IMPLEMENTED "
		retval = [0, 0, 0, 0]
		return retval 

	#Get the total travelled distance in meters
	def getTravelledDistance(self):
            retval = 0

            x0, y0, z0 = -1, -1, -1
            started = False

            for line in self._readlines([TAG_COORDINATE]):
                x, y, z = [float(u) for u in line[2:]]
                if started:
                    retval += math.sqrt(pow(x - x0, 2) + pow(y - y0, 2) + pow(z - z0, 2))
                else:
                    started = True #Kickstart x0 etc
                x0, y0, z0 = x, y, z

                    
            
	    return retval

	#Get the GPS coordinates of points contained in a certain timerange (or all of them)
	def getPoints(self, timeRange=None):
                print(inspect.currentframe().f_code.co_name) + "    NO IMPLEMENTED "
		if not timeRange:
			timeRange = [self.getStartTime(), self.getEndTime()]

		start, stop = timeRange
		Points = [] 
		return Points

	############################### Access point discovery related functions

	# get a list of list of scan results (one list for each attempt)
	# This function does not assume grouping by physical APs and will return a list of Networks
	def getScanResults(self, gpsRange=None):
		scans = {}
                ssids = []

                for res in self._readlines([TAG_SCAN]):
                    timestamp, _, scanInd, scanType, ssid, rssi = res
                    timestamp = int(timestamp)
                    scanInd = int(scanInd)
                    rssi = int(rssi)
                    if scanInd not in scans:
                        scans[scanInd] = []

                    if ssid not in ssids:
                        ssids.append(ssid)

                    scans[scanInd].append(Network(bssid = intToBssid(ssids.index(ssid)), ssid=ssid, detections=[Detection(source = SourceHelper.ORIGIN_NS3, timestamp = timestamp, rssi = rssi, scanInd = scanInd)]))

		return scans.values()


	#Retrieve list of all APs seen in the trace
	# This Ill-named function does not group by physical APs and will return a list of Networks with detections corresponding to their ssid
	def getApList(self):
		retval = {}
                ssids = []

                for res in self._readlines([TAG_SCAN]):
                    timestamp, _, scanInd, scanType, ssid, rssi = res
                    timestamp = int(timestamp)
                    scanInd = int(scanInd)
                    rssi = int(rssi)

                    if ssid not in ssids:
                        ssids.append(ssid)

                    if ssid not in retval:
                        retval[ssid] = Network(bssid = intToBssid(ssids.index(ssid)), ssid=ssid, detections=[Detection(source = SourceHelper.ORIGIN_NS3, timestamp = timestamp, rssi = rssi, scanInd = scanInd)])
                        
                    else:
                        retval[ssid].detections.append(Detection(source = SourceHelper.ORIGIN_NS3, timestamp = timestamp, rssi = rssi, scanInd = scanInd))

		return retval.values()

	#Return the number of scan attempts
	def countScans(self):
                print(inspect.currentframe().f_code.co_name) + "    NO IMPLEMENTED "
		retval = 0
		return retval

	############################### Device Event related functions

	#Get device connectivity events
	def getEvents(self, eventTypes =[]):
                retval = []

                for res in self._readlines([TAG_L2EVENT]):
                    if len(res) == 6:
                        timestamp, _, ekey, bssid, ssid, rssi = res
                        etype = L2EVENTS[ekey]
                        rssi = int(rssi)
                        timestamp = int(timestamp)
                        network = Network(ssid = ssid, bssid = bssid, detections=[Detection(source = "ns3", GPS = (0, 0), timestamp = timestamp, rssi = rssi)])
                        if len(eventTypes)==0 or etype in eventTypes:
                            retval.append(ConnectionEvent(state = etype, timestamp = timestamp, network = network))

                #for res in self._readlines(TAG_L3EVENT):

		retval = sorted(retval, key = lambda x : x.timestamp)

		return retval

	#Get device community network events
	def getCNEvents(self, eventTypes):
                print(inspect.currentframe().f_code.co_name) + "    NO IMPLEMENTED "
		return []

	############################### Transmitted Data related functions

	#Get a list of the data transfer events, with the associated AP
	def getTransferredData(self):
		retval = []
        
                totalbytes = 0
                lastBytes = 0
                rssi = -200

                for res in self._readlines([TAG_TRAFFIC, TAG_L2EVENT]):
                    if res[1] == TAG_TRAFFIC and len(res) == 6:
                        timestamp, _, local, remote, direction, totalbytes = res
                        timestamp = int(timestamp)
                        totalbytes = int(totalbytes)

                        byt = totalbytes - lastBytes
                    
    	        	network = Network(detections=[Detection(source = "ns3", GPS = (0, 0), timestamp = timestamp, rssi = rssi)])
        		retval.append(TransferredData(network, byt, 0, LINK_WIFI, direction))

                    elif res[1] == TAG_L2EVENT:
                        if res[2] == "3": #Rssi Change Event
                            rssi = int(res[5])
                        elif res[2] == "2": #Disconnected, reset the data counter
                            lastBytes = totalbytes

		return retval

	def getTotalTransferredBytes(self, maxts = -1):
            totalbytes = 0

            for res in self._readlines([TAG_TRAFFIC]):
                if len(res)  == 6:
                    if maxts == -1 or int(res[0]) < maxts:
                        totalbytes = res[5]

            return int(totalbytes)
